#!/usr/bin/env python3

import os
import sys
import struct
import json

import sys
sys.path.append("..")

from qiling import Qiling
from qiling.os.memory import QlMemoryHeap
from qiling.os.posix.filestruct import ql_socket
from qiling.os.posix import syscall
from qiling.os.posix.const import *
from qiling.os.posix.filestruct import ql_socket
from qiling.os.posix.syscall.unistd import virtual_abspath_at, get_opened_fd
from qiling.os.posix.syscall.socket import __host_socket_level, __host_socket_option
from qiling.extensions.coverage.utils import collect_coverage
from qiling.const import QL_VERBOSE
from qiling.os.const import STRING, INT

DEBUG = False

def pdebug(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)

def alloc(ql, param):
    addr = ql.os.heap.alloc(len(param)+1)
    ql.mem.string(addr, param + '\0')
    return addr

def free(ql, param):
    return ql.os.heap.free(param)

class NVRam(object):
    _default_storage = {
        "odmpid": "RT-AX55",
        "productid": "RT-AX55",
    }
    _storage = dict()
    def __init__(self, ql, path=None, fail=False) -> None:
        self.ql = ql
        self.fail = fail
        for k in self._default_storage:
            addr = alloc(self.ql, self._default_storage[k])
            self._storage[k] = addr
        if path:
            self.load_file(path)

    def load_file(self, path):
        file_storage = json.load(open(path, 'r'))
        for k in file_storage:
            addr = alloc(self.ql, file_storage[k])
            self._storage[k] = addr

    def get(self, name):
        if name in self._storage:
            x = self._storage[name]
            return x
        else:
            if self.fail:
                raise AttributeError(name)
            return alloc(self.ql, "\0")

    def get_int(self, name):
        value = self.ql.mem.string(self.get(name))
        try:
            return int(value, 10)
        except ValueError:
            return 0

    def set(self, name, value):
        addr = alloc(self.ql, value)
        self._storage[name] = addr
        return 0
    
    def set_int(self, name, value):
        self.set(name, str(value))
        return 0

    def unset(self, name):
        if name in self._storage:
            free(self.ql, self._storage[name])
        else:
            if self.fail:
                raise AttributeError(name)


def ql_syscall_nanosleep(ql, nanosleep_req, nanosleep_rem, *args, **kw):
    return 0

def ql_syscall_write(ql, write_fd, write_buf, write_count, *rest):
    if write_fd == 2 and ql.os.fd[2].__class__.__name__ == 'ql_pipe':
        return -1

    f = get_opened_fd(ql.os, write_fd)
    data = ql.mem.read(write_buf, write_count)
    name = f.getsockname() if type(f) is ql_socket else f.name
    if write_fd == 2:
        return -1
    else:
        print(f'write(): {data.decode()}')
    #if b" socke " in data:
    #    raise KeyboardInterrupt()
    return syscall.ql_syscall_write(ql, write_fd, write_buf, write_count, *rest)  

def ql_syscall_read(ql: Qiling, fd, buf: int, length: int):
    f = get_opened_fd(ql.os, fd)
    if f is None:
        return -1

    try:
        data = f.read(length)
        ql.mem.write(buf, data)
    except BlockingIOError as e:
        print(e)
        regreturn = -EBADF
    except Exception as e:
        print(e)
        regreturn = -EBADF
    else:
        print(f'read(): {data!r}')
        regreturn = len(data)

    return regreturn

def ql_syscall_lseek(ql: Qiling, fd: int, offset_high: int, offset_low: int, result: int, whence: int):
    offset = ql.unpack64s(ql.pack64((offset_high << 32) | offset_low))

    if fd not in range(NR_OPEN):
        regreturn = -1

    f = ql.os.fd[fd]

    if f is None:
        regreturn = -1

    ret = 0
    return 200
    if type(f) is ql_socket:
        ql.mem.write_ptr(result, ret, 8)
    
    else:
        try:
            ret = f.seek(offset, whence)
        except OSError:
            regreturn = -1
        else:
            ql.mem.write_ptr(result, ret, 8)
            regreturn = 0

    return regreturn

def hook_do_set_iperf3_srv(ql):
    pdebug('hook_do_set_iperf3_srv')
    pdebug(hex(ql.arch.regs.arch_pc))
    post_json_buf = 0x000a1d14
    #ql.mem.string(post_json_buf, "{'iperf3_svr_port': '8888', 'rc_service': '%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%n%n%n%n%n%n%n%n%n%n%n%n%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'}")
    pdebug(ql.mem.string(post_json_buf))
    #ql.hook_code(tracer)

def hook_nvram_get(ql):
    pdebug('hook_nvram_get')
    params = ql.os.resolve_fcall_params({'key': STRING})
    value = ql.nvram.get(params["key"])
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = {ql.mem.string(value)}')
    ql.arch.regs.r0 = value

def hook_nvram_set(ql):
    pdebug('hook_nvram_set')
    params = ql.os.resolve_fcall_params({'key': STRING,'value': STRING})
    value = ql.nvram.set(params["key"], params["value"])
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = {params["value"]}')
    ql.arch.regs.r0 = value

def hook_nvram_unset(ql):
    pdebug('hook_nvram_unset')
    params = ql.os.resolve_fcall_params({'key': STRING})
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = ""')
    ql.nvram.unset(params["key"])
    ql.arch.regs.r0 = 0

def hook_nvram_get_int(ql):
    pdebug('hook_nvram_get_int')
    params = ql.os.resolve_fcall_params({'key': STRING})
    value = ql.nvram.get_int(params["key"])
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = {value}')
    ql.arch.regs.r0 = value

def hook_nvram_set_int(ql):
    pdebug('hook_nvram_set_int')
    params = ql.os.resolve_fcall_params({'key': STRING,'value':INT})
    value = ql.nvram.set_int(params["key"], params["value"])
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = {params["value"]}')
    ql.arch.regs.r0 = value

def hook_nvram_commit(ql):
    pdebug('hook_nvram_commit')
    ql.arch.regs.r0 = 1

def hook_nvram_match(ql):
    pdebug('hook_nvram_match')
    params = ql.os.resolve_fcall_params({'key': STRING,'value':STRING})
    value = ql.nvram.get(params["key"])
    pdebug(f'{params["key"]} ({hex(ql.arch.regs.r0)}) = ({ql.mem.string(value)} == {params["value"]})')
    ql.arch.regs.r0 = (ql.mem.string(value) == params["value"])

def my_sandbox(path, rootfs, verbose=QL_VERBOSE.DEFAULT):
    ql = Qiling(path, rootfs, verbose=verbose, multithread=True)

    ql.debugger = False
    #ql.debugger = "gdb:0.0.0.0:9999"

    heap_address = 0x6ff0d000
    heap_size = 0x30000
    ql.os.heap = QlMemoryHeap(ql, heap_address, heap_address + heap_size)
    ql.nvram = NVRam(ql, "nvram.json", fail=False)

    ql.os.set_syscall("nanosleep", ql_syscall_nanosleep)
    ql.os.set_syscall("_llseek", ql_syscall_lseek)
    ql.os.set_syscall("write", ql_syscall_write)
    ql.os.set_syscall("read", ql_syscall_read)
    
    ql.hook_address(hook_do_set_iperf3_srv, 0x420e0)

    ql.os.set_api('nvram_get', hook_nvram_get)
    ql.os.set_api('nvram_set', hook_nvram_set)
    ql.os.set_api('nvram_unset', hook_nvram_unset)
    ql.os.set_api('nvram_get_int', hook_nvram_get_int)
    ql.os.set_api('nvram_set_int', hook_nvram_set_int)
    ql.os.set_api('nvram_commit', hook_nvram_commit)
    ql.os.set_api('nvram_match', hook_nvram_match)
    
    with collect_coverage(ql, 'ezcov', 'output_ez.cov'):
        ql.run()
    

if __name__ == "__main__":
    try:
        os.remove("_RT-AX55_51598/squashfs-root/var/run/httpd.pid")
        os.remove("_RT-AX55_51598/squashfs-root/var/run/httpd.lock")
    except FileNotFoundError:
        pass
    verbose = QL_VERBOSE.OFF
    if len(sys.argv) == 2:
        verbose = QL_VERBOSE.DEBUG
    my_sandbox(["_RT-AX55_51598/squashfs-root/usr/sbin/httpd"], "_RT-AX55_51598/squashfs-root/", verbose=verbose)

    
